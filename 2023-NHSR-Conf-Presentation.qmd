---
title: "Old dog and new tricks - Learning to {purrr}"
author: "Tom Smith<br>Insight Manager<br>Nottingham University Hospitals NHS Trust"
format: 
  revealjs:
    slide-number: true
    incremental: true
    output-file: index.html
    theme: [default, css/custom_styles.scss]
---

## purrr for functional programming

![](img/purrr.jpg){fig-align="center"}

Ahhh, a friendly cat...

## Scary functional programming

![](img/purrr.jpg){fig-align="center"}

Run away now!

## Aims

* Don't be scary!

. . .  

:::{.nonincremental}
* Practical intro to purrr
* A "mental model" which helped me

* Helpful examples
  + Easy to adapt
:::

. . .  

Functional programming is for another day (and another speaker!)

## I wouldn't start from here

From the tidyverse documentation: 

> "the best place to start is the family of map() functions which allow you to replace many for loops with code that is both more succinct and easier to read."

and: 

> "The best place to learn about the map() functions is the [iteration chapter in R for data science.](https://r4ds.had.co.nz/iteration.html)"

::: {.notes}
Purrr is part of the tidyverse, and both of these comments are true.  

The first hints at the fact that once you grasp the map() function, you'll already be able to use it's close relations in helpful ways.  

The second says the best place to learn is Hadley's book R for Data Science.  In the meantime I hope this presentation helps, and at the end there are links to these and other resources.
:::

## Loops vs. Map

Why should I learn how to use map()?

## Loop example

```{r}
#| echo: true
#| output-location: fragment

# we need a vector to iterate over
food <- c("croissant", "baked potato")

# we need to create a place to put the results (the right size)
result <- vector("character", length(food))

# here's the loop
for(i in seq_along(food)){
  
  result[[i]] <- paste("Hot", food[[i]])
  
}

result

```

## Map example

```{r}
#| echo: true
#| output-location: fragment

# we still need a vector to iterate over
food <- c("croissant", "baked potato")

# we create a function to do the "work"
heat_the_food <- function(food){
  
  paste("Hot", food)

}

# here's the loop
result <- purrr::map(food, heat_the_food)

result

```
::: {.notes}
Ignore for a moment the shape of the result.  In the loop example we got a vector back.  In the map example we have a list.  We'll come back to that shortly.

But even with that difference you're sceptical.  Tom, you're short-changing us.  We're happy with loops.  14 lines of code.  You're talking about map() being simpler, and you still took 14 lines.  

Lets go back and look in more detail...  
:::

## Comparison {auto-animate=true}

loop 
```{.r}

# we need a vector to iterate over
food <- c("croissant", "baked potato")

# we need to create a place to put the results (the right size)
result <- vector("character", length(food))

# here's the loop
for(i in seq_along(food)){
  
  result[[i]] <- paste("Hot", food[[i]])
  
}

result

```

## Comparison {auto-animate=true}
map
```{.r}

# we need a vector to iterate over
food <- c("croissant", "baked potato")

# we create a function to do the "work"
heat_the_food <- function(food){
  
  paste("Hot", food)

}

# here's the loop
result <- purrr::map(food, heat_the_food)

result

```

## Comparison {auto-animate=true}

loop 
```{.r code-line-numbers="|6|9|11"}

# we need a vector to iterate over
food <- c("croissant", "baked potato")

# we need to create a place to put the results (the right size)
result <- vector("character", length(food))

# here's the loop
for(i in seq_along(food)){
  
  result[[i]] <- paste("Hot", food[[i]])
  
}

result

```

There is more "boilerplate" code in a loop, and code explanations end up in comments (which might not exist)

## Comparison {auto-animate=true}
map
```{.r code-line-numbers="|6|8|13"}

# we need a vector to iterate over
food <- c("croissant", "baked potato")

# we create a function to do the "work"
heat_the_food <- function(food){
  
  paste("Hot", food)

}

# here's the loop
result <- purrr::map(food, heat_the_food)

result

```

The code is easier to read, and we can use function names not comments to describe what it's doing

## Arguments

```{.r}
purrr::map(.x, .f)

# .x A list or atomic vector
# .f A function


```

### Mental model
```{.r}
purrr::map(food, heat_the_food)

purrr::map(subjects, action)

purrr::map(noun, verb)

purrr::map(raw_material, instructions)

purrr::map(ingredients, recipe)

```

## Cakes!

purrr::map(.x, .f)  

:::: columns
::: {.column width="30%" .fragment .centre}
.x  
![](img/cake-x.jpg){width=300}
:::
::: {.column width="30%" .fragment .centre}
.f  
![](img/cake-f.jpg){width=300}
:::
::: {.column width="10%" .fragment .centre}
=
:::
::: {.column width="30%" .fragment .centre}
result  
![](img/cake-res.jpg){width=300}
:::
::::

## Cars!

purrr::map(.x, .f)  

:::: columns
::: {.column width="30%" .fragment .centre}
.x  
![](img/car-x.jpg){width=300}
:::
::: {.column width="30%" .fragment .centre}
.f  
![](img/car-f.png){width=300}
:::
::: {.column width="10%" .fragment .centre}
=
:::
::: {.column width="30%" .fragment .centre}
result  
![](img/car-res.jpg){width=300}
:::
::::

## Ikea!

purrr::map(.x, .f)  

:::: columns
::: {.column width="30%" .fragment .centre}
.x  
![](img/ikea-x.avif){width=300}
:::
::: {.column width="30%" .fragment .centre}
.f  
![](img/ikea-f.jpg){width=300}
:::
::: {.column width="10%" .fragment .centre}
=
:::
::: {.column width="30%" .fragment .centre}
result  
![](img/ikea-res.avif){width=300}
:::
::::


## Some things we haven't covered

* The shape of the output  
  As standard, the map functions return a list containing your result
  What if we don't want that.  What if we just want a vector back, or a dataframe?
  use the suffix functions instead...
  map_vec
  
* map vs. walk
  If the important part of your function is it's side-effects, you can use walk instead of map.  This doesn't return a list, but a vector of TRUE / FALSE.
  
* mapping over more than one variable
  Sometimes you may need to vary more than one input to the function at a time
  with 2 items to very, use map2
  With a general number to vary, use pmap

## Further online training

::::: {.columns}

:::: {.column width="50%"}
Tom Jemmett's video
<iframe width="400" height="220" src="https://www.youtube.com/embed/GxvccD8K49M" allowfullscreen></iframe>  

::: {.tiny-text}
<https://www.youtube.com/GxvccD8K49M>
:::

::::

:::: {.column width="50%"}
Hadley Wickham's video
<iframe width="400" height="220" src="https://www.youtube.com/embed/EGAs7zuRutY" allowfullscreen></iframe>  

::: {.tiny-text}
<https://www.youtube.com/EGAs7zuRutY>
:::

::::

:::::

The iteration chapter of R for Data Science:  
<https://r4ds.had.co.nz/iteration.html#iteration>

The purrr docs:  
<https://purrr.tidyverse.org>

Cheatsheet:
<https://rstudio.github.io/cheatsheets/purrr.pdf>

## Open-source

![](img/github-mark.svg){width=30} Online presentation: <https://thomuk.github.io/2023-NHSR-Conf-Presentation>

![](img/github-mark.svg){width=30} Presentation code: <https://github.com/ThomUK/2023-NHSR-Conf-Presentation>

![](img/github-mark.svg){width=30} Other repos: <https://github.com/ThomUK>

## Thank you

![](img/grass-question-mark.png){fig-align="center"}

